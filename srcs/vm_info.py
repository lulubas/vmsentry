import libvirt
import logging
import subprocess
import re
from enum import Enum
from datetime import datetime, timedelta
from init_config import Config
from utils import read_lines_from_file, read_content_from_file, extract_timestamp_from_log, is_valid_ip
from ip_manage import is_ip_blocked

#Enum to name the different states a VM can take (from libvirt)
class DomainState(Enum):
	NOSTATE = 0
	RUNNING = 1
	BLOCKED = 2
	PAUSED = 3
	SHUTDOWN = 4
	SHUTOFF = 5
	CRASHED = 6
	PMSUSPENDED = 7

# Fetch information about the VMs on this node
def get_vm_info(config: Config):
		
	#Use libvirt to connect to the local hypervisor
	conn = None
	try:
		conn = libvirt.open('qemu:///system')
		if conn is None:
			logging.info('Failed to open connection to qemu:///system')
			return

		#Create a dictionnay to store VMs information
		vms = []

		# Get all VMs, including active and inactive
		for domain in conn.listAllDomains():

			#Get the VM name
			name = domain.name()

			#Get the VM sate
			state_code = domain.state()[0]
			state = DomainState(state_code).name

			#Get the VM mac address and IP address
			xml_desc = domain.XMLDesc()
			mac_addresses = re.findall(r"<mac address='([^']+)'/>", xml_desc)
			mac_addr = mac_addresses[0] if mac_addresses else None

			#Get the IP using arp
			ip_addr = get_ip_from_arp(mac_addr)

			#Sometimes arp does not have the IP then use DHCP configuration file
			if not ip_addr:
				ip_addr = get_ip_from_dhcpd(domain.name())
			
			if is_valid_ip(ip_addr) is False:
				logging.error(f"IP fetched ({ip_addr}) for {name} not valid")

			#Initialize the ditionnary values to save the VM information
			vm_info = {
				'name': domain.name(),
				'id': domain.ID(),
				'state': state,
				'mac': mac_addr,
				'ip': ip_addr,
				'smtp_connections': 0,
				'unique_dst_ips': set(),
				'blocked' : is_ip_blocked(ip_addr)
			}
			vms.append(vm_info)

	except libvirt.libvirtError as e:
		logging.error(f"Failed to list VMs: {e}")
		return

	finally:
		if conn is not None:
			conn.close()
	
	#Associate SMTP activity to each VM in the data object and return it 
	parse_smtp_activity(vms, config)

	#Add if the IP address is currently blocked 
	
	#Print out VMs info and activity summary per VM
	print_vms_info(vms, config)

	logging.info(f'VM data and stmp activity parsed')

	return(vms)

#Fetch the IP address associated with a given Mac address using the arp command
def get_ip_from_arp(mac_address):
	try:
		# Run the arp -n command and get its output
		arp_output = subprocess.check_output('arp -n', shell=True).decode()

		# Regular expression to find the IP address associated with the given MAC address
		match = re.search(r'^(\S+)\s+ether\s+' + re.escape(mac_address) + r'\s+C\s+', arp_output, re.MULTILINE)
		
		if match:
			ip = match.group(1)
			if is_valid_ip(ip):
				return ip

	except subprocess.CalledProcessError as e:
		print(f"Error executing arp -n: {e}")

	return None

#fetch the IP address of a specific vmid using DHCP conf file
def get_ip_from_dhcpd(vmid, file_path='/etc/dhcp/dhcpd.conf'):
	try:
		content = read_content_from_file(file_path)

		# Regular expression to find relevant IP address based on the vmid
		pattern = rf'host vm{vmid} {{.*?fixed-address (\S+);'
		match = re.search(pattern, content, re.DOTALL)
	
		if match:
			ip = match.group(1)
			if is_valid_ip(ip):
				return ip
	
	except Exception as e:
		print(f"Error reading {file_path}: {e}")
	
	return None

# Parse iptables logs and extract SMTP connections per IP and unique destination IPs
def parse_smtp_activity(vms, config: Config, filepath = '/etc/vmsentry/logs/iptables_all_25.log'):
	#Read iptables logs generated by rsyslog
	try:
		log_lines = read_lines_from_file(filepath)
	except FileNotFoundError:
		logging.error('iptables_all_25.log file does not exist (yet). You might need to wait until logs are generated.')
		raise
	
	#Matching pattern to exctract the source and destination IP of a specific SMTP connetion
	pattern = r"SRC=(?P<src>\S+) DST=(?P<dst>\S+) .* DPT=25"

	#Generate the timeframe during which logs should be accounted for using the setting set in config.ini
	timeframe = datetime.now() - timedelta(hours=config.timeframe)

	#Go through each SMTP connetion and append the update the VM information
	for line in log_lines:
		try:
			#Exctract the timestamp and parse the src and dst ips if it is within the timeframe
			timestamp = extract_timestamp_from_log(line)
			
			if timestamp > timeframe:
				match = re.search(pattern, line)
				src_ip = match.group('src')
				dst_ip = match.group('dst')

				if match and is_valid_ip(src_ip) and is_valid_ip(dst_ip):
					
					#Flag to make sure the src IP was assigned to an existing VM
					ip_found = False
					
					#Loop through the VMs to associate the smtp traffic to them
					for vm in vms:
						if vm['ip'] == src_ip:
							vm['smtp_connections'] += 1
							vm['unique_dst_ips'].add(match.group('dst'))
							ip_found = True
							break
					
					if not ip_found:
						logging.error(f"Could not associate {src_ip} to a VM. Log line: {line}")

				else:
					logging.error(f"Impossible to assign the iptables log to an actual source/destination IP. ({line})")
		
		except Exception as e:
			logging.error(f'Error while parsing the line "{line}": {e}. Skipping.')
			continue

#Print out the VMs information and SMTP activity parsed from the logs
def print_vms_info(vms, config: Config):
	#Columns widths
	column_widths = {'name': 10, 'state': 8, 'ip': 15, 'smtp_connections': 16, 'unique_dst_ips': 10, 'blocked': 10}
	total_width = sum(column_widths.values()) + len(column_widths) * 3

	# Title top border
	print("+" + "-" * (total_width - 2) + "+")

	# Title centered within the box
	title = f"VM Network Activity Summary (past {config.timeframe} hours)"
	print("|" + title.center(total_width - 2) + "|")

	# Title bottom border
	print("+" + "-" * (total_width - 2) + "+")

	#Headers
	print(f"{'VM Name':{column_widths['name']}} | "
		f"{'State':{column_widths['state']}} | "
		f"{'IP':{column_widths['ip']}} | "
		f"{'SMTP Connections':{column_widths['smtp_connections']}} | "
		f"{'Unique IPs':{column_widths['unique_dst_ips']}} | "
		f"{'Blocked':{column_widths['blocked']}}")

	#Rows
	for vm in vms:

		#Create the string representation of the VPS blocked status
		blocked_status = "BLOCKED" if vm['blocked'] else ""

		print(f"{vm['name']:{column_widths['name']}} | "
			f"{vm['state']:{column_widths['state']}} | "
			f"{vm['ip']:{column_widths['ip']}} | "
			f"{vm['smtp_connections']:{column_widths['smtp_connections']}} | "
		  	f"{len(vm['unique_dst_ips']):{column_widths['unique_dst_ips']}} | "
			f"{blocked_status:{column_widths['blocked']}}")
		
	# Table bottom border 
	print("-" * total_width)
	